<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Питонические атаки</title><link href="https://semakin.dev/" rel="alternate"></link><link href="https://semakin.dev/feeds/all.atom.xml" rel="self"></link><id>https://semakin.dev/</id><updated>2020-04-22T22:35:44+05:00</updated><subtitle>Про разработку в целом и в частности про Python</subtitle><entry><title>requirements.txt — что это и зачем?</title><link href="https://semakin.dev/2020/04/requirements_txt/" rel="alternate"></link><published>2020-04-22T22:00:00+05:00</published><updated>2020-04-22T22:35:44+05:00</updated><author><name>and-semakin</name></author><id>tag:semakin.dev,2020-04-22:/2020/04/requirements_txt/</id><summary type="html">&lt;p&gt;Расскажу, как создавать и как пользоваться этим файлом для хранения дерева зависимостей проекта.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;requirements.txt&lt;/h1&gt;
&lt;p&gt;В исходниках множества Python-проектов можно встретить этот
странный текстовый файл. Например, им пользуются
&lt;a href="https://github.com/urllib3/urllib3/blob/master/dev-requirements.txt"&gt;urllib3&lt;/a&gt;,
&lt;a href="https://github.com/numpy/numpy/blob/master/test_requirements.txt"&gt;numpy&lt;/a&gt;,
&lt;a href="https://github.com/pandas-dev/pandas/blob/master/requirements-dev.txt"&gt;pandas&lt;/a&gt;,
&lt;a href="https://gitlab.com/pycqa/flake8/-/blob/master/dev-requirements.txt"&gt;flake8&lt;/a&gt;
и куча других проектов.
Давайте разберемся, что это такое, как этим пользоваться и зачем нам это нужно.&lt;/p&gt;
&lt;h2&gt;Гипотетическая предыстория&lt;/h2&gt;
&lt;p&gt;Давайте представим, что вы написали &lt;em&gt;замечательный&lt;/em&gt; скрипт,
который спрашивает у пользователя название города и
выводит текущую температуру и общее состояние погоды:&lt;/p&gt;
&lt;script src="https://gist.github.com/and-semakin/1e999af221df36afbeec5909a413081a.js?file=weather.py"&gt;&lt;/script&gt;
&lt;p&gt;Скрипт получился настолько хорош, что вы хотите поделиться
им со всеми своими друзьями. К сожалению, друзья при попытке
запустить вашу программу получают следующую ошибку:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"weather.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyowm&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;OWM&lt;/span&gt;
&lt;span class="n"&gt;ModuleNotFoundError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;named&lt;/span&gt; &lt;span class="s1"&gt;'pyowm'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Кажется, что скинуть только код недостаточно.&lt;/p&gt;
&lt;p&gt;Или, допустим, что вы сами через полгода-год попытаетесь
запустить эту же программу. За это время вы успели пару
раз переустановить Python, переустановить ОС, отформатировать свой
магнитный накопитель (используйте SSD — нет, я серьёзно!)
или может быть вообще сменили компьютер.
Почти уверен, что при запуске скрипта вы получите ровно ту же самую ошибку.&lt;/p&gt;
&lt;p&gt;Зачастую, когда мы пишем код, мы полагаемся на какие-либо
библиотеки или фреймворки. Это со всех сторон хорошо — это удобно,
уменьшает размер программы во много раз, позволяет не думать о мелких деталях,
а решать свою конкретную задачу, опираясь на высокоуровневые абстракции.
Но, к сожалению, есть "но" — такие библиотеки становятся
частью вашей программы, ваш код становится &lt;em&gt;зависим&lt;/em&gt;.
Это значит, что ваш код больше не сможет
работать сам по себе, для его работы должны быть установлены &lt;em&gt;все зависимости&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Если ваша программа небольшая (состоит из пары файлов), то можно
довольно легко просмотреть её глазами, найти там все инструкции &lt;code&gt;import&lt;/code&gt;,
отсеять из них импорты из стандартной библиотеки
(вы ведь знаете модули стандартной библиотеки наизусть, да?), и таким образом
восстановить список внешних зависимостей программы, которые устанавливаются
через &lt;code&gt;pip&lt;/code&gt;. Чем крупнее проект, тем сложнее это сделать. Бывают ситуации,
когда по коду вообще нельзя понять, что ему нужна определенная зависимость.&lt;/p&gt;
&lt;p&gt;Я хочу сказать, что намного мудрее составлять этот список зависимостей
сразу же и просто поддерживать его в актуальном состоянии по мере развития проекта.&lt;/p&gt;
&lt;h2&gt;requirements.txt — это список внешних зависимостей&lt;/h2&gt;
&lt;p&gt;Сообщество Python &lt;a href="https://www.python.org/dev/peps/pep-0020/"&gt;исповедует идеологию&lt;/a&gt;
"простое лучше, чем сложное".
Наверное, поэтому для хранения списка зависимостей сообщество выбрало
самый простой из возможных форматов — текстовый файл, где на каждой
строке перечислено ровно по одной зависимости.&lt;/p&gt;
&lt;p&gt;Стоит отметить, что &lt;code&gt;requirements.txt&lt;/code&gt; не является стандартом, т.е. нет
документа, который описывал бы требования к этому файлу.
Скорее, это просто распространённая практика в сообществе, которая,
наверное, возникла спонтанно и хорошо прижилась.&lt;/p&gt;
&lt;p&gt;Не обязательно называть файл именно &lt;code&gt;requirements.txt&lt;/code&gt;, можно назвать
его как угодно, лишь бы его назначение оставалось понятно.
Я встречал такие вариации, как
&lt;code&gt;requirements-dev.txt&lt;/code&gt;, &lt;code&gt;test-requirements.txt&lt;/code&gt;, &lt;code&gt;requirements/docs.txt&lt;/code&gt;
и другие.&lt;/p&gt;
&lt;p&gt;Вот пример самого простого такого файла (кстати, именно этим файлом
можно описать зависимости, которые нужны для запуска нашего скрипта
с погодой):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pyowm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Если бы было несколько зависимостей, то файл выглядел бы так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;numpy
requests
pytest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Можно указать конкретную версию зависимости. Если версия не указана, то
считается, что нужна последняя доступная:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;numpy  # нужна последняя версия
requests==2.23.0  # нужна конкретная версия
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Можно указывать диапазоны и другие более сложные &lt;a href="https://www.python.org/dev/peps/pep-0440/#version-specifiers"&gt;"спецификаторы версий"&lt;/a&gt;.
В целом, в &lt;code&gt;requirements.txt&lt;/code&gt; можно писать любые "запросы", которые понимает команда
&lt;code&gt;pip install&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;requests&amp;gt;=2.20.0,&amp;lt;2.23.0  # подойдет любая версия между 2.20.0 и 2.23.0
numpy!=1.0  # подойдет любая версия, кроме 1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Как пользоваться&lt;/h2&gt;
&lt;p&gt;Команда &lt;code&gt;pip install&lt;/code&gt; умеет читать такие файлы, если передать специальный флаг:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ pip install --help
...
Install Options:
  -r, --requirement &amp;lt;file&amp;gt;    Install from the given requirements file. This option can be used multiple times.
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Таким образом, если &lt;code&gt;requirements.txt&lt;/code&gt; будет иметь вот такое содержимое:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pytest
flake8
black
isort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;То следующие две команды будут иметь одинаковое действие:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ pip install -r requirements.txt

$ pip install pytest flake8 black isort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Преимущества использования &lt;code&gt;requirements.txt&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Краткость.&lt;/p&gt;
&lt;p&gt;На таком маленьком примере разница может быть не очевидна, но
когда список зависимостей разрастётся до определенного размера,
то вам не захочется больше перечислять его в &lt;code&gt;pip install&lt;/code&gt; напрямую.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Стабильность.&lt;/p&gt;
&lt;p&gt;Как бы ни поменялся файл &lt;code&gt;requirements.txt&lt;/code&gt;, команда &lt;code&gt;pip install -r requirements.txt&lt;/code&gt;
не поменяется.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Универсальность.&lt;/p&gt;
&lt;p&gt;Так как это распространённое соглашение, то другим разработчикам
будет достаточно увидеть этот файл, чтобы понять, что нужно сделать. Это
здорово экономит время на чтении инструкций.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Как создать&lt;/h2&gt;
&lt;p&gt;Есть два подхода:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;создавать этот файл вручную;&lt;/li&gt;
&lt;li&gt;генерировать автоматически.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Главный принцип ручного подхода — если что-то поменялось в списке зависимостей
(добавилась или удалилась зависимость, обновилась версия и т.д.), это изменение
нужно отразить в &lt;code&gt;requirements.txt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Но можно использовать и встроенную в &lt;code&gt;pip&lt;/code&gt; функциональность:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $ pip freeze
&lt;span class="nv"&gt;certifi&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2020&lt;/span&gt;.4.5.1
&lt;span class="nv"&gt;chardet&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.0.4
&lt;span class="nv"&gt;geojson&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.5.0
&lt;span class="nv"&gt;idna&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.9
&lt;span class="nv"&gt;pyowm&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.10.0
&lt;span class="nv"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.23.0
&lt;span class="nv"&gt;urllib3&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.25.9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Команда &lt;code&gt;pip freeze&lt;/code&gt; выводит все установленные в интерпретатор сторонние пакеты.
Заметьте, что в список попали не только прямые зависимости (&lt;code&gt;pyowm&lt;/code&gt;), но
и подзависимости — это даже лучше, потому что вы сможете более
точно воссоздать окружение по этому файлу.&lt;/p&gt;
&lt;p&gt;Можно перенаправить вывод этой команды в файл при помощи стандартного &lt;a href="https://losst.ru/vyvod-v-fajl-bash-v-linux#1_%D0%9F%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0_%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0"&gt;консольного
приема&lt;/a&gt;
(работает и на Windows), и получить валидный файл &lt;code&gt;requirements.txt&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $ pip freeze &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Обратите внимание, что &lt;code&gt;pip freeze&lt;/code&gt; выведет список пакетов в том окружении,
в котором он запущен. Не забудьте активировать виртуальное окружение перед
запуском этой команды, иначе получите список пакетов, установленных в глобальный
интерпретатор. Кстати, у меня есть
&lt;a href="https://semakin.dev/2020/04/python_virtualenv/"&gt;пост про виртуальные окружения&lt;/a&gt;, где объясняется
как ими пользоваться.&lt;/p&gt;
&lt;p&gt;Подытожим плюсы и минусы ручного и автоматического подходов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Вручную:&lt;ul&gt;
&lt;li&gt;минимальный файл, содержащий только прямые зависимости;&lt;/li&gt;
&lt;li&gt;можно указывать сложные спецификаторы версий;&lt;/li&gt;
&lt;li&gt;человеческий фактор — легко ошибиться или забыть что-нибудь;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip freeze&lt;/code&gt;:&lt;ul&gt;
&lt;li&gt;автоматически, быстро;&lt;/li&gt;
&lt;li&gt;автоматически добавляет версии установленных пакетов;&lt;/li&gt;
&lt;li&gt;в файл попадет всё дерево зависимостей, а не только прямые зависимости.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Можно использовать и смешанный подход: сгенерировать начальную версию файла
при помощи &lt;code&gt;pip freeze&lt;/code&gt; и допилить её затем руками, если у вас какая-то
сложная нестандартная ситуация.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⚠️ Файл &lt;code&gt;requirements.txt&lt;/code&gt;, конечно же, должен быть добавлен в систему
контроля версий (git). Это такая же важная часть проекта, как и код.
При этом виртуальное окружение не должно попадать в систему контроля
версий. Оно должно воссоздаваться из &lt;code&gt;requirements.txt&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Проблемы &lt;code&gt;requirements.txt&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Некоторые пакеты часто меняются, поэтому если вы не указываете конкретные
версии, то в следующий раз при установке вы можете получить совсем другую
среду. Это бывает особенно обидно, когда локально на машине разработчика
всё работает правильно, но при деплое на боевой сервер программа либо работает
иначе, либо вообще отказывается запускаться. Поэтому обязательно фиксируйте
версии пакетов в &lt;code&gt;requirements.txt&lt;/code&gt; — это сделает разные окружения хотя бы
примерно похожими.&lt;/p&gt;
&lt;p&gt;Почему "хотя бы примерно"? Практика показывает, что зафиксировать версию
пакета недостаточно. Иногда случается, что под одной версией пакета в разное
время может находиться совершенно разный код. PyPI, конечно, не позволит
перезаписать уже опубликованную версию, но, например, ваш приватный
корпоративный индекс пакетов может быть не таким строгим.&lt;/p&gt;
&lt;p&gt;Чтобы действительно гарантировать, что вы устанавливаете те пакеты, что и
ожидали, нужно рассчитывать и сверять их контрольные суммы. &lt;code&gt;requirements.txt&lt;/code&gt;
может содержать хэши пакетов, но, к сожалению, на данный момент нет
простого стандартного способа как их туда положить. В качестве альтернативы
опять предлагаю присмотреться к таким проектам, как
&lt;a href="https://python-poetry.org/"&gt;&lt;code&gt;poetry&lt;/code&gt;&lt;/a&gt; (хранит хэши в &lt;code&gt;poetry.lock&lt;/code&gt;)
и &lt;a href="https://github.com/pypa/pipenv"&gt;&lt;code&gt;pipenv&lt;/code&gt;&lt;/a&gt; (хранит хэши в &lt;code&gt;Pipfile.lock&lt;/code&gt;), где эта
проблема решена хорошо,
и вам не придётся переживать о воспроизводимости ваших сборок.
Если всё-таки хочется добиться такого же эффекта при помощи
&lt;code&gt;requirements.txt&lt;/code&gt;, то можно посмотреть на такие проекты как
&lt;a href="https://github.com/jazzband/pip-tools"&gt;&lt;code&gt;pip-tools&lt;/code&gt;&lt;/a&gt;
(&lt;a href="https://github.com/pypa/pip/issues/4732#issuecomment-500289841"&gt;пример использования&lt;/a&gt;)
и &lt;a href="https://github.com/peterbe/hashin"&gt;&lt;code&gt;hashin&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Заключение&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;requirements.txt&lt;/code&gt; — это очень популярный способ хранения списка внешних
зависимостей проекта, поэтому вам определенно нужно уметь работать с
такими файлами. Однако этот способ хранения списка зависимостей не лишён
недостатков, поэтому если вы начинаете новый проект, то я предлагаю вам
лучше использовать для этого &lt;a href="https://python-poetry.org/"&gt;&lt;code&gt;poetry&lt;/code&gt;&lt;/a&gt;
или &lt;a href="https://github.com/pypa/pipenv"&gt;&lt;code&gt;pipenv&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Для тренировки можно попытаться запустить скрипт с погодой.
Все исходники лежат &lt;a href="https://gist.github.com/and-semakin/1e999af221df36afbeec5909a413081a"&gt;здесь&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Дополнительное чтение&lt;/h2&gt;
&lt;p&gt;Конечно, я затронул лишь верхушку айсберга. На самом деле,
&lt;code&gt;requirements&lt;/code&gt;-файлы немножко сложнее.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files"&gt;Секция PIP User Guide про requirements.txt&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;А вот тут &lt;a href="https://pip.pypa.io/en/stable/reference/pip_install/#requirements-file-format"&gt;подробное описание формата &lt;code&gt;requirements&lt;/code&gt;-файлов&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;А ещё &lt;a href="https://pip.pypa.io/en/stable/user_guide/#constraints-files"&gt;бывают &lt;code&gt;constraints.txt&lt;/code&gt;&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Бонус: PyCharm &lt;a href="https://www.jetbrains.com/help/pycharm/managing-dependencies.html"&gt;умеет умно обновлять &lt;code&gt;requirements.txt&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Подпишитесь!&lt;/h2&gt;
&lt;p&gt;Чтобы получить уведомление о новом посте можно:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://t.me/pythonic_attacks"&gt;подписаться на канал в Telegram&lt;/a&gt;
(&lt;a href="https://tele.click/pythonic_attacks"&gt;альтернативная&lt;/a&gt; &lt;a href="https://tele.gg/pythonic_attacks"&gt;ссылка&lt;/a&gt;);&lt;/li&gt;
&lt;li&gt;&lt;a href="/feeds/all.atom.xml"&gt;подписаться на Atom-фид&lt;/a&gt;, если &lt;s&gt;вы олдфаг-старовер&lt;/s&gt; вам так удобно.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Обложка: &lt;a href="https://www.flickr.com/photos/mustangjoe/14675770684"&gt;Joe deSousa, Gnarled Tree&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</content><category term="blog"></category><category term="python"></category><category term="pip"></category><category term="requirements.txt"></category></entry><entry><title>Виртуальные окружения в Python</title><link href="https://semakin.dev/2020/04/python_virtualenv/" rel="alternate"></link><published>2020-04-18T20:42:16+05:00</published><updated>2020-04-19T20:08:10+05:00</updated><author><name>and-semakin</name></author><id>tag:semakin.dev,2020-04-18:/2020/04/python_virtualenv/</id><summary type="html">&lt;p&gt;Почему всегда нужно использовать виртуальные окружения и как правильно их готовить.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Python знаменит своей обширной стандартной библиотекой и девизом
"батарейки в комплекте"
(&lt;a href="https://docs.python.org/3/tutorial/stdlib.html#batteries-included"&gt;batteries included&lt;/a&gt;).
Даже из коробки Python позволяет удобно и быстро решить огромный пласт задач,
например, например, работа с файлами, запуск простого веб-сервера,
работа с электронной почтой, парсинг XML и JSON, и так далее. Во всяком случае,
это намного удобнее, чем писать shell-скрипты 😅&lt;/p&gt;
&lt;p&gt;Кроме того, у Python имеется огромная экосистема сторонних библиотек,
поддерживаемых сообществом энтузиастов. Эти библиотеки реализуют отсутствующую
в стандартной поставке функциональность, либо пере-реализуют уже имеющуюся, но
удобнее. Если у вас возникла потребность в какой-то функциональности, то
почти наверняка кто-то уже написал для этого библиотеку, и нужно просто погуглить.&lt;/p&gt;
&lt;h2&gt;Установка сторонней библиотеки&lt;/h2&gt;
&lt;p&gt;Каждый начинающий программист знает, как установить библиотеку. Набираем&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ pip install requests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;и понеслась! Множество библиотек в своих инструкциях по установке именно так
и предлагают их устанавливать. Это и правда работает, это и правда так просто,
&lt;em&gt;но есть нюансы&lt;/em&gt;. В этом месте закопаны очень популярные грабли, по которым
прошлось множество начинающих питонистов, в том числе и я.&lt;/p&gt;
&lt;h3&gt;Как &lt;code&gt;pip&lt;/code&gt; устанавливает пакеты&lt;/h3&gt;
&lt;p&gt;Давайте разберемся, что же происходит, когда юзер набирает в терминал такую
команду. В общих чертах происходит следующее.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;pip&lt;/code&gt; обращается в &lt;a href="https://pypi.org/"&gt;PyPI&lt;/a&gt; (Python Package Index) и
находит там запрашиваемый пакет.&lt;/li&gt;
&lt;li&gt;Пакет скачивается. Обычно это просто zip-архив, который содержит
код библиотеки, разложенный внутри согласно формату. Современным и
рекомендуемым форматом пакетов является wheel (&lt;a href="https://www.python.org/dev/peps/pep-0427/"&gt;PEP-427&lt;/a&gt;),
но в дикой природе встречаются и другие форматы.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip&lt;/code&gt; устанавливает пакет.&lt;/li&gt;
&lt;li&gt;Библиотека установлена, ее можно импортировать и использовать.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Давайте подробнее разберем третий шаг. Установка пакета — звучит загадочно и
сложно, но на самом деле ничего сложного здесь не происходит. &lt;code&gt;pip&lt;/code&gt; просто
распаковывает zip-архив в определенное место (это справедливо для формата wheel,
для установки пакетов в других форматах могут потребоваться дополнительные
действия, но давайте разберем самый распространённый и простой случай). Куда
именно происходит установка? Это можно узнать, выполнив следующую команду:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python -m site
sys.path &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;
    &lt;span class="s1"&gt;'/Users/and-semakin'&lt;/span&gt;,
    &lt;span class="s1"&gt;'/Users/and-semakin/.asdf/installs/python/3.8.2/lib/python38.zip'&lt;/span&gt;,
    &lt;span class="s1"&gt;'/Users/and-semakin/.asdf/installs/python/3.8.2/lib/python3.8'&lt;/span&gt;,
    &lt;span class="s1"&gt;'/Users/and-semakin/.asdf/installs/python/3.8.2/lib/python3.8/lib-dynload'&lt;/span&gt;,
    &lt;span class="s1"&gt;'/Users/and-semakin/env/lib/python3.8/site-packages'&lt;/span&gt;,
&lt;span class="o"&gt;]&lt;/span&gt;
USER_BASE: &lt;span class="s1"&gt;'/Users/and-semakin/.local'&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;exists&lt;span class="o"&gt;)&lt;/span&gt;
USER_SITE: &lt;span class="s1"&gt;'/Users/and-semakin/.local/lib/python3.8/site-packages'&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;doesn&lt;span class="err"&gt;'&lt;/span&gt;t exist&lt;span class="o"&gt;)&lt;/span&gt;
ENABLE_USER_SITE: False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В списке &lt;code&gt;sys.path&lt;/code&gt; можно увидеть директорию &lt;code&gt;site-packages&lt;/code&gt; — именно туда
и будет установлена библиотека. Давайте в этом убедимся.&lt;/p&gt;
&lt;p&gt;До установки пакета:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls -l /Users/and-semakin/env/lib/python3.8/site-packages
total &lt;span class="m"&gt;8&lt;/span&gt;
drwxr-xr-x   &lt;span class="m"&gt;3&lt;/span&gt; and-semakin  awesome    &lt;span class="m"&gt;96&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 __pycache__
-rw-r--r--   &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;126&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 easy_install.py
drwxr-xr-x   &lt;span class="m"&gt;7&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;224&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 pip
drwxr-xr-x   &lt;span class="m"&gt;9&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;288&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 pip-19.2.3.dist-info
drwxr-xr-x   &lt;span class="m"&gt;7&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;224&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 pkg_resources
drwxr-xr-x  &lt;span class="m"&gt;42&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;1344&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 setuptools
drwxr-xr-x  &lt;span class="m"&gt;11&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;352&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 setuptools-41.2.0.dist-info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Установим пакет:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ pip install requests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;После установки пакета:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls -l /Users/and-semakin/env/lib/python3.8/site-packages
total &lt;span class="m"&gt;8&lt;/span&gt;
drwxr-xr-x   &lt;span class="m"&gt;3&lt;/span&gt; and-semakin  awesome    &lt;span class="m"&gt;96&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 __pycache__
drwxr-xr-x   &lt;span class="m"&gt;7&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;224&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 certifi
drwxr-xr-x   &lt;span class="m"&gt;8&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;256&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 certifi-2020.4.5.1.dist-info
drwxr-xr-x  &lt;span class="m"&gt;43&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;1376&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 chardet
drwxr-xr-x  &lt;span class="m"&gt;10&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;320&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 chardet-3.0.4.dist-info
-rw-r--r--   &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;126&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 easy_install.py
drwxr-xr-x  &lt;span class="m"&gt;11&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;352&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 idna
drwxr-xr-x   &lt;span class="m"&gt;8&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;256&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 idna-2.9.dist-info
drwxr-xr-x   &lt;span class="m"&gt;7&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;224&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 pip
drwxr-xr-x   &lt;span class="m"&gt;9&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;288&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 pip-19.2.3.dist-info
drwxr-xr-x   &lt;span class="m"&gt;7&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;224&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 pkg_resources
drwxr-xr-x  &lt;span class="m"&gt;21&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;672&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 requests
drwxr-xr-x   &lt;span class="m"&gt;8&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;256&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 requests-2.23.0.dist-info
drwxr-xr-x  &lt;span class="m"&gt;42&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;1344&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 setuptools
drwxr-xr-x  &lt;span class="m"&gt;11&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;352&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:39 setuptools-41.2.0.dist-info
drwxr-xr-x  &lt;span class="m"&gt;16&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;512&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 urllib3
drwxr-xr-x   &lt;span class="m"&gt;8&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;256&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;17&lt;/span&gt;:41 urllib3-1.25.9.dist-info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Как видим, в директорию &lt;code&gt;site-packages&lt;/code&gt; добавилась библиотека &lt;code&gt;requests&lt;/code&gt; вместе
со всеми своими зависимостями.&lt;/p&gt;
&lt;p&gt;Важные мысли, которые я пытаюсь донести:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;установка библиотеки напрямую влияет на файловую систему;&lt;/li&gt;
&lt;li&gt;у интерпретатора Python есть &lt;strong&gt;только одна&lt;/strong&gt; директория &lt;code&gt;site-packages&lt;/code&gt;, куда
&lt;code&gt;pip&lt;/code&gt; и устанавливает пакеты.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;А это значит, что в один интерпретатор Python нельзя установить две версии
одной библиотеки одновременно. При установке новой версии предыдущая "перезатирается".
Просто как если бы вы распаковали другой архив с совпадающими именами файлов
в то же самое место.&lt;/p&gt;
&lt;h3&gt;Боль — это жизненный опыт&lt;/h3&gt;
&lt;p&gt;Что же будет, если вам понадобится работать над двумя проектами, которые
будут требовать разных, не совместимых между собой версий одной и той же
библиотеки? Возможно, между этими версиями в библиотеку были внесены
какие-то крупные ломающие изменения, например, переименовались методы/функции
или изменился набор аргументов.&lt;/p&gt;
&lt;p&gt;Например, проект А:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# requirements.txt
requests==2.23.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Проект Б:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# requirements.txt
requests==1.2.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Вы просто не сможете работать над такими проектами одновременно. Установка
зависимостей одного проекта сломает другой, и наоборот. При переключении между
проектами придётся каждый раз устанавливать зависимости нужного проекта, что
довольно легко забыть сделать.&lt;/p&gt;
&lt;p&gt;Ситуация кажется маловероятной, но я гарантирую, что рано или поздно это
случится, если устанавливать зависимости всех своих проектов в один интерпретатор.
Всё усугубляется тем фактом, что прямые зависимости вашего проекта тянут за
собой свои зависимости (под-зависимости),
те, в свою очередь, тоже могут от чего-то зависеть (под-под-зависимости). В
итоге вы получаете целое дерево зависимостей. И если где-то в этом дереве
окажется библиотека не той версии, что ожидалось, то весь проект может начать
очень странно работать. Вы получите такие эзотерические ошибки, которых
еще никто в интернете до вас не встречал. Если всё сразу сломалось, то считайте,
что легко отделались — по крайней мере, так довольно просто понять, в чём проблема.
Но бывают и ситуации намного хуже, когда приложение просто начинает &lt;em&gt;немножко&lt;/em&gt;
иначе работать, без каких-либо ошибок, и возможно придется потратить долгие
часы на траблшутинг, чтобы найти настоящую причину.&lt;/p&gt;
&lt;p&gt;Надеюсь, я убедил вас, что устанавливать зависимости нескольких проектов в
один интерпретатор — это очень-очень плохо. Но как же тогда правильно?&lt;/p&gt;
&lt;h2&gt;Виртуальные окружения&lt;/h2&gt;
&lt;p&gt;Решение очевидно — у каждого проекта должен быть свой интерпретатор Python,
со своей собственной изолированной директорией &lt;code&gt;site-packages&lt;/code&gt;. Это и есть
основная идея, стоящая за виртуальными окружениями. Виртуальное окружение —
это самостоятельная копия интерпретатора со своими пакетами.&lt;/p&gt;
&lt;h3&gt;Как создавать виртуальные окружения&lt;/h3&gt;
&lt;p&gt;Начиная с Python версии 3.5 (на данный момент это самая старая из официально
поддерживаемых версий языка, так что справедливо ожидать, что как минимум
везде установлен Python 3.5 или новее), создать виртуальное окружение стало
очень просто:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python -m venv &amp;lt;путь к виртуальному окружению&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Например, допустим, что мы работаем над проектом &lt;code&gt;blog_source&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# заходим в директорию с проектом&lt;/span&gt;
$ &lt;span class="nb"&gt;cd&lt;/span&gt; src/blog_source

&lt;span class="c1"&gt;# создаем виртуальное окружение прямо рядом с кодом в директории env&lt;/span&gt;
$ python -m venv env
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Создавать виртуальное окружения рядом с кодом — это распространённая практика,
так проще ничего не перепутать, но вообще виртуальное окружение может быть
где угодно, и директория тоже может называться как угодно. Обратите внимание,
что если вы создаете виртуальное окружение в директории под управлением
системы контроля версий (git), то его не нужно коммитить.
Лучше вообще добавьте его (&lt;code&gt;env/&lt;/code&gt;) в &lt;code&gt;.gitignore&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В директорию &lt;code&gt;env&lt;/code&gt; будет скопирован тот самый интерпретатор, при помощи
которого виртуальное окружение и создавалось. Т.е. если&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ python -V
Python &lt;span class="m"&gt;3&lt;/span&gt;.8.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;то в виртуальном окружении будет та же самая версия:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ env/bin/python -V
Python &lt;span class="m"&gt;3&lt;/span&gt;.8.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Активируем окружение&lt;/h3&gt;
&lt;p&gt;Посмотрим, что внутри директории &lt;code&gt;env&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ ls -l env/
total &lt;span class="m"&gt;8&lt;/span&gt;
drwxr-xr-x  &lt;span class="m"&gt;13&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;416&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 bin
drwxr-xr-x   &lt;span class="m"&gt;2&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;64&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 include
drwxr-xr-x   &lt;span class="m"&gt;3&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;96&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 lib
-rw-r--r--   &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;113&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 pyvenv.cfg

$ ls -l env/bin/
total &lt;span class="m"&gt;88&lt;/span&gt;
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;8471&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 Activate.ps1
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;2218&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 activate
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;1270&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 activate.csh
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome  &lt;span class="m"&gt;2422&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 activate.fish
-rwxr-xr-x  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;268&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 easy_install
-rwxr-xr-x  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;268&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 easy_install-3.8
-rwxr-xr-x  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;250&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 pip
-rwxr-xr-x  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;250&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 pip3
-rwxr-xr-x  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome   &lt;span class="m"&gt;250&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 pip3.8
lrwxr-xr-x  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome    &lt;span class="m"&gt;59&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 python -&amp;gt; /Users/and-semakin/.asdf/installs/python/3.8.2/bin/python
lrwxr-xr-x  &lt;span class="m"&gt;1&lt;/span&gt; and-semakin  awesome     &lt;span class="m"&gt;6&lt;/span&gt; Apr &lt;span class="m"&gt;18&lt;/span&gt; &lt;span class="m"&gt;18&lt;/span&gt;:55 python3 -&amp;gt; python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Обратите внимание, что в директории &lt;code&gt;bin&lt;/code&gt; есть некий файл &lt;code&gt;activate&lt;/code&gt; в
нескольких вариантах для разных шеллов. Это и есть "точка входа" в виртуальное
окружение. Просто создать виртуальное окружение мало, нужно его активировать.
Но сначала проверим, какие &lt;code&gt;python&lt;/code&gt; и &lt;code&gt;pip&lt;/code&gt; (исполняемые файлы) используются
в обычном режиме работы:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ which python
/Users/and-semakin/.asdf/shims/python
$ which pip
/Users/and-semakin/.asdf/shims/pip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Это мой обычный Python, вне виртуального окружения, назовём его глобальным.
Теперь активируем виртуальное окружение:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ &lt;span class="nb"&gt;source&lt;/span&gt; env/bin/activate
&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Для Windows процесс активации будет отличаться (допустим, что виртуальное окружение
создано в &lt;code&gt;C:\src\blog_source&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# cmd&lt;/span&gt;
C:&lt;span class="se"&gt;\s&lt;/span&gt;rc&lt;span class="se"&gt;\b&lt;/span&gt;log_source&lt;span class="se"&gt;\&amp;gt;&lt;/span&gt; env&lt;span class="se"&gt;\S&lt;/span&gt;cripts&lt;span class="se"&gt;\a&lt;/span&gt;ctivate.bat

&lt;span class="c1"&gt;# либо в PowerShell&lt;/span&gt;
PS C:&lt;span class="se"&gt;\s&lt;/span&gt;rc&lt;span class="se"&gt;\b&lt;/span&gt;log_source&lt;span class="se"&gt;\&amp;gt;&lt;/span&gt; env&lt;span class="se"&gt;\S&lt;/span&gt;cripts&lt;span class="se"&gt;\A&lt;/span&gt;ctivate.ps1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Обратите внимание, что приветствие шелла изменилось (добавилось &lt;code&gt;(env)&lt;/code&gt;), чтобы
показать, что мы "внутри" виртуального окружения под названием &lt;code&gt;env&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Теперь проверим еще раз, какие &lt;code&gt;python&lt;/code&gt; и &lt;code&gt;pip&lt;/code&gt; используются:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $ which python
/Users/and-semakin/src/blog_source/env/bin/python
&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $ which pip
/Users/and-semakin/src/blog_source/env/bin/pip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Посмотрите на пути — мы внутри виртуального окружения! Теперь можно смело
устанавливать любые пакеты, и это никак не повлияет на глобальный Python или
на другие виртуальные окружения:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $ pip install requests flask whatever-you-need
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Можно запускать любые файлы, и они будут иметь доступ к установленным пакетам:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $ python make_money.py
Done! You are rich!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IDE тоже нужно настроить, указав путь к &lt;code&gt;bin/python&lt;/code&gt; внутри виртуального
окружения, тогда редактор сможет лучше вам помогать.&lt;/p&gt;
&lt;p&gt;По завершению работы с виртуальным окружением можно просто набрать &lt;code&gt;deactivate&lt;/code&gt;,
либо закрыть окно терминала:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(&lt;/span&gt;env&lt;span class="o"&gt;)&lt;/span&gt; $ deactivate
$ which python
/Users/and-semakin/.asdf/shims/python
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;И мы видим, что команда &lt;code&gt;python&lt;/code&gt; снова вызывает глобальный интерпретатор.
При этом виртуальное окружение осталось в своей директории, оно просто не
активно. В следующий раз, когда будет нужно поработать с виртуальным
окружением, не забудьте снова его активировать.&lt;/p&gt;
&lt;p&gt;Виртуальное окружение можно полностью удалить, когда оно перестанет быть
нужным:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ rm -r env/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;В идеале, у вас должна быть возможность в любой момент удалить и пересоздать
виртуальное окружение заново, для этого храните список зависимостей проекта и
содержите его в актуальном состоянии (например, в &lt;code&gt;requirements.txt&lt;/code&gt;).
В процессе разработки могут случиться всякие казусы с зависимостями,
и иногда проще пересоздать виртуальное окружение заново, чем пытаться
починить сломанное.&lt;/p&gt;
&lt;p&gt;Вот так можно работать с виртуальными окружениями в Python. Всегда устанавливайте
зависимости проектов только в изолированные виртуальные окружения. Не смешивайте
зависимости разных проектов в одном окружении.&lt;/p&gt;
&lt;p&gt;Когда в инструкции по установке библиотеки написано &lt;code&gt;pip install ...&lt;/code&gt;,
подразумевается, что у читателя есть понимание, что он делает. Думаю,
разработчики библиотек не пишут про создание виртуальных окружений
только потому, что это сильно раздуло бы все инструкции.&lt;/p&gt;
&lt;h2&gt;Ничего не устанавливайте в глобальный интерпретатор&lt;/h2&gt;
&lt;p&gt;Иногда возникает желание установить какой-нибудь пакет прямо в глобальный
интерпретатор, потому что по смыслу этот пакет вроде как должен быть вне
виртуальных окружений. Например, это может быть какая-нибудь программа,
типа &lt;a href="https://python-poetry.org/"&gt;&lt;code&gt;poetry&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://docs.docker.com/compose/"&gt;&lt;code&gt;docker-compose&lt;/code&gt;&lt;/a&gt;,
&lt;a href="https://github.com/ytdl-org/youtube-dl"&gt;&lt;code&gt;youtube-dl&lt;/code&gt;&lt;/a&gt; или
&lt;a href="https://pypi.org/project/howdoi/"&gt;&lt;code&gt;howdoi&lt;/code&gt;&lt;/a&gt;. Руки набирают в терминал:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ pip install poetry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Установка начинается, прогресс-бары заполняются, но в итоге всё завершается
чем-то типа такого:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;could&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="s1"&gt;'/lib/python2.7/site-packages/poetry'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Permission&lt;/span&gt; &lt;span class="n"&gt;denied&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Можно попробовать установить, используя &lt;code&gt;sudo&lt;/code&gt;, и это сработает, но это
считается &lt;a href="https://ru.stackoverflow.com/q/651860/340643"&gt;очень плохой практикой&lt;/a&gt;,
и я настоятельно рекомендую так не делать по нескольким причинам:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Угроза безопасности.&lt;/p&gt;
&lt;p&gt;В секции про установку пакетов я упомянул, что для пакетов других форматов,
кроме wheel, могут потребоваться дополнительные действия. На самом деле,
при установке пакета формата &lt;code&gt;sdist&lt;/code&gt; исполняется файл&lt;code&gt;setup.py&lt;/code&gt;, в котором
потенциально могут содержаться любые действия — от честной установки пакета,
до &lt;code&gt;rm -rf /&lt;/code&gt; или установки криптомайнера в систему. Т.к. в PyPI пакет
загрузить может кто угодно, никогда нельзя быть уверенным, что именно сделает пакет
при установке. Выполнять такой скрипт с системными привилегиями (&lt;code&gt;sudo&lt;/code&gt;) —
не самый мудрый ход.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Может нарушить целостность системы.&lt;/p&gt;
&lt;p&gt;Часто в операционных системах принято устанавливать программы через
пакетный менеджер (будь то &lt;code&gt;apt&lt;/code&gt;, &lt;code&gt;dnf&lt;/code&gt; или &lt;code&gt;pacman&lt;/code&gt;). Этот же пакетный
менеджер затем может без следа удалить установленную программу, потому что он
ведёт учёт файлов — какой программе какие файлы принадлежит. Если начать
изменять файлы программ каким-либо образом, помимо пакетного менеджера,
то это может нарушить его работу. &lt;code&gt;pip&lt;/code&gt;, конечно, установит что нужно,
но после этого могут возникнуть проблемы с системным пакетным менеджером.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Как правильно:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;сказать &lt;code&gt;pip&lt;/code&gt;, чтобы он установил пакет не в директорию &lt;code&gt;site-packages&lt;/code&gt;, а в
домашнюю директорию пользователя при помощи флага &lt;code&gt;--user&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ pip install --user poetry  # без sudo!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Нужно только убедиться, что нужная директория перечислена в переменной &lt;code&gt;$PATH&lt;/code&gt;
— в моём случае это &lt;code&gt;~/.local/bin&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;установить программу через пакетный менеджер ОС, например:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo dnf install python-poetry&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Часто мейнтейнеры ОС создают обёртки для пакетов из PyPI, которые можно
установить при помощи системного пакетного менеджера. Как правило, такие
обёртки называются &lt;code&gt;python-&amp;lt;имя пакета&amp;gt;&lt;/code&gt; или &lt;code&gt;python3-&amp;lt;имя пакета&amp;gt;&lt;/code&gt;.
Это делается как раз для того, чтобы дать пользователям возможность
устанавливать Python-программы, не нарушая работу пакетного менеджера ОС.
Кроме того, эти пакеты проходят проверку безопасности, так что риск получить
криптомайнер значительно ниже.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Выводы&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;всегда устанавливайте зависимости проектов в отдельные виртуальные окружения;&lt;/li&gt;
&lt;li&gt;если нужно установить пакет "глобально", то используйте либо &lt;code&gt;pip install --user ...&lt;/code&gt;,
либо прибегните к помощи пакетного менеджера операционной системы;&lt;/li&gt;
&lt;li&gt;никогда не используйте &lt;code&gt;sudo pip ...&lt;/code&gt; — считайте, что это табу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Да, виртуальные окружения — определенно не самая удобная часть разработки на
Python, и уж точно не самая простая тема, к этому просто нужно привыкнуть.
Несколько раз повторил, выработал привычку — в целом, ничего сложного.
Кроме того, экосистема Python развивается очень быстро, и я надеюсь,
что скоро правильная установка пакетов
и управление виртуальными окружениями станут намного легче.
Уже сейчас можно пользоваться такими инструментами,
которые в некоторой мере прячут от пользователя виртуальные окружения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://python-poetry.org/"&gt;poetry&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pypa/pipenv"&gt;pipenv&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Стабильных вам зависимостей и кода без багов!&lt;/p&gt;
&lt;h2&gt;Полезно почитать:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Документация: &lt;a href="https://docs.python.org/3/library/venv.html"&gt;https://docs.python.org/3/library/venv.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="blog"></category><category term="python"></category><category term="pip"></category><category term="venv"></category><category term="virtualenv"></category></entry></feed>